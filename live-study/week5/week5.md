# 5주차 - 클래스
본 글은 [백기선님의 live-study](https://github.com/whiteship/live-study/issues)를 진행하며 작성한 자료입니다. 자료에서 사용한 **예제 코드**는 직접 만들었습니다.

<br/>

# ✔ 목표
자바의 Class에 대해 학습하세요.

<br/>

# ✔ 목차
* 클래스 정의하는 방법
* 객체 만드는 방법 (new 키워드 이해하기)
* 메소드 정의하는 방법
* 생성자 정의하는 방법
* this 키워드 이해하기

<br/>

# 💡 5-1 클래스 정의하는 방법

일반적으로 **소스 파일**당 하나의 클래스를 선언한다. 두 개 이상도 가능하다. 소스 파일은 클래스 선언을 담고 있는 **저장 단위**일 뿐, 클래스 자체가 아니라서 클래스를 선언한 개수만큼 바이트 코드 파일`.class` 이 생성된다.

<br/>

파일의 이름과 클래스 이름은 다르게 지어도 된다.(`public` 접근 제어자가 아닐 때) 동일 패키지 내부에 있다면 찾을 수 있다. 다만 해당 클래스파일을 외부 패키지에서 사용할 수 있게 하기 위해서는 `public` 접근제어자를 앞에 붙여야 하는데 **`public` 접근제어자가 붙는 클래스는 파일과 이름이 동일**해야한다.

<br/>
  
## **작성 규칙**
  * 하나 이상의 문자로 이루어져야 한다.
  * 첫 번째 글자는 숫자가 올 수 없다.
  * `$`, `_` 외의 특수 문자는 사용할 수 없다.
  * 자바 키워드는 사용할 수 없다.

<br/>

## **클래스의 구성 멤버**

* **필드(field)** : 필드는 해당 클래스 객체의 상태 속성을 나타내며, 멤버 변수라고도 불린다. 여기서 초기화하는 것을 필드 초기화 또는 명시적 초기화라고 한다.

  * **인스턴스 변수** - 이름에서 알 수 있듯이 인스턴스가 갖는 변수이다. 그렇기에 인스턴스를 생성할 때 만들어진다. 서로 독립적인 값을 갖으므로 heap 영역에 할당되고 gc에 의해 관리된다.

  * **클래스 변수** - 정적을 의미하는 `static` 키워드가 인스턴스 변수 앞에 붙으면 클래스 변수이다. 해당 클래스에서 파생된 모든 인스턴스는 이 변수를 공유한다. 그렇기 때문에 heap 영역이 아닌 `static` 영역에 할당되고 gc의 관리를 받지 않는다. 또한 `public` 키워드까지 앞에 붙이면 전역 변수라 볼 수 있다.

<br/>

* **메서드(method)** : 메서드는 해당 객체의 행동을 나타내며, 보통 필드의 값을 조정하는데 쓰인다.

  * **인스턴스 메서드** - 인스턴스 변수와 연관된 작업을 하는 메서드이다. 인스턴스를 통해 호출할 수 있으므로 반드시 먼저 인스턴스를 생성해야 한다.

  * **클래스 메서드** - 정적 메서드라고도 한다. 일반적으로 인스턴스와 관계없는 메서드를 클래스 메서드로 정의한다.

<br/>

* **생성자(constructor)** : 생성자는 객체가 생성된 직후에 클래스의 객체를 초기화하는 데 사용되는 코드 블록이다. 메서드와 달리 리턴 타입이 없으며, 클래스엔 최소 한 개 이상의 생성자가 존재한다.

<br/>

* **초기화 블록(initializer)** : 초기화 블록 내에서는 조건문, 반복문 등을 사용해 필드 초기화에서는 불가능한 초기화를 할 수 있다. 

  * **클래스 초기화 블록** - 클래스 변수 초기화에 쓰인다.

  * **인스턴스 초기화 블록** - 인스턴스 변수 초기화에 쓰인다.


  * 초기화 블록은 생성자 생성 전에 호출된다.

  * 인스턴스 초기화 블록과 생성자가 동일한 인스턴스 변수를 초기화하는 경우, 변수값은 생성자에 의해 결정된다.

  ```java
  public class Init {
    int num1;
    static int num2;

    static {
        System.out.println("클래스 초기화 블록");
        num2 = 100;
    }

    {
        System.out.println("인스턴스 초기화 블록");
        num1 = 10;
    }

    public Init(int num1) {
        System.out.println("생성자 블록");
        this.num1 = num1;
    }

    public static void main(String[] args) {
        Init init = new Init(1000);
        System.out.println("num1 : " + init.num1);
        System.out.println("num2 : " + Init.num2);
    }
  } 
  ```

  결과화면

  ```
  클래스 초기화 블록
  인스턴스 초기화 블록
  생성자 블록
  num1 : 1000
  num2 : 100
  ```

<br/>

* **접근지정자**
  | 접근지정자 | 클래스 내부 | 동일 패키지 | 하위 클래스 | 그 외 영역
  | :---: | :---: | :---: | :---: | :---: |
  public | o | o | o | o
  protected | o | o | o | x
  private | o | o | x | x
  default | o | x | x | x

<br/>

# 💡 5-2 객체 만드는 방법 (new 키워드 이해하기)

* 클래스를 정의했다면 클래스로부터 객체를 만들어 사용해야한다. 이러한 과정을 **클래스의 인스턴스화**라 정의한다. 

* 객체는 **new 키워드**를 이용해 생성이 가능하다. 
  
* **new 키워드를 이용하면 메모리 힙 영역에 데이터를 저장할 영역을 할당 받은 후 해당 영역의 주소를 객체에게 반환하여 객체를 사용할수 있도록 만들어준다.**

```java
Car car1 = new Car();
Car car2 = new Car("company", "model", 10);

car1.getSpeed();
car2.getSpeed();
```

<br/>

# 💡 5-3 메소드 정의하는 방법

```java
//리턴 타입 + 메소드이름 + 매개변수선언
int getSpeed() { ... }
```
* 메소드의 내부에는 자신이 원하는 로직을 작성할 수 있다.

* **네이밍 컨벤션**
    * 메소드의 이름은 동사를 포함해야한다.
        * speed (x) , getSpeed (o)

    * 각 단어의 첫글자는 소문자로, 나머지는 대문자로한다.(카멜 케이스)
        * getSpeed (o), Getspeed (x)

* **자바 코딩 컨벤션은 회사마다 조금씩 다르게 사용하지만 대체적으로 거의 비슷하니 일반적으로 사용하는 컨벤션들은 외워두는것이 좋다.**

* **메소드를 정의할 때 중요한 기법이 메소드 오버로딩과 오버라이딩이다.**
    * **메소드 오버로딩**
      * 메소드 오버로딩은 매개 변수의 개수, 타입, 순서 중 하나가 다르고 동일한 이름의 메소드명을 사용해 메소드를 정의할 수 있는 기법이다. 
      * 매개 변수의 순서, 타입, 개수가 동일하고 리턴 타입이 다른 경우에는 메소드 오버로딩이 성립하지 않는다.

    * **메소드 오버라이딩**
      * 메소드 오버라이딩은 상위 클래스가 정의한 메소드를 하위 클래스가 가져와 변경하거나 확장하는 기법, 즉 하위 클래스에서 메소드를 재정의하는 기법이다.


<br/>

# 💡 5-4 생성자 정의하는 방법
* 생성자
  * 변수를 선언하고 초기화하는 것과 마찬가지로 **클래스를 생성하고 객체를 호출할 때 객체를 초기화** 하기 위해 사용되는 것이 **생성자**이다.
  
  * 아래 예제와 같이 다양한 Car 클래스의 생성자를 만들어 `생성자 오버로딩`이 가능하다.
  * `this()` 를 사용해 다른 생성자 호출이 가능하다.
  * 클래스 내부에 생성자를 선언하지 않으면 컴파일러가 기본 생성자를 선언해 사용한다.
  * **명시적 생성자(매개 변수를 가진 생성자)만 선언되있는 경우** **파라미터가 없는 생성자를 사용하고 싶다면 묵시적 생성자(매개 변수가 없는 생성자)를 선언**해주어야한다. (생성자가 클래스 내부에 선언되어 있기 때문에 **기본 생성자가 생성되지 않는다**.)

```java
    public class Car {
    //필드
    String company;
    String model;
    int speed;

    //디폴트 생성자
    Car() { ... }

    //매개 변수를 가진 생성자
    Car(String company, String model, int speed){ 
        this.company = company;
        this.model = model;
        this.speed = speed;
     }

    //생성자 내에서 다른 생성자 호출
    Car(String model){
        this("company", model, 10);
    }

    //차량의 speed를 가져오는 메소드
    int getSpeed() { ... }
}
```

<br/>

# 💡 5-5 this키워드 이해하기

## **this**

* 자기 자신을 가르키는 참조 변수
* `this` 키워드를 이용해 클래스 내부의 필드이름과 매개 변수를 구분해준다.

```java
Car(String company, String model, int speed){ 
    this.company = company;
    this.model = model;
    this.speed = speed;
  }
```

<br/>

## **this()**

* 자신의 생성자를 의미한다.
* 생성자의 가장 첫 줄에서 사용해야한다.

```java
//생성자 내에서 다른 생성자 호출
Car(String model){
    this("company", model, 10);
}
```

<br/>

# 💡 추가) Method Signature, Method Type

Method Signature 는 그것만으로 메소드를 구분지을 수 있는 근거가 되어야 한다.

자바에서 메서드 시그니처는 **메서드명, 인자**이다.

```java
public class Signature {
    void method(int a){}
    void method(String a) {} // 정상 작동
    void method(int a, int b) {} // 정상 작동
    int method(int a) {} //컴파일 에러 발생
}
```

위의 코드를 보면 정확히는 **인자의 타입, 갯수, 메서드명**이 메서드 시그니처라는 것을 알 수 있다. 리턴 타입은 포함되지 않는다.

<br/>

# 참고
* 이것이 자바다 - 신용권
* https://www.notion.so/Live-Study-5-75f857b63e524d33914a8b3ec6e1e894
* https://leemoono.tistory.com/17

