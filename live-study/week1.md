# 1주차 - JVM
본 글은 [백기선님의 live-study](https://github.com/whiteship/live-study/issues)를 진행하며 작성한 자료입니다.  

## 목표
자바 소스 파일(.java)을 JVM으로 실행하는 과정 이해하기

## 목차
* JVM이란 무엇인가
* 바이트코드란 무엇인가
* JIT 컴파일러란 무엇이며 어떻게 동작하는지
* JVM 구성 요소
* JDK와 JRE의 차이
* 컴파일 하는 방법
* 실행하는 방법

## 1-1 JVM이란 무엇인가
  
### **JVM 이란** 
* 운영체제는 자바 프로그램을 바로 실행할 수 없는데, 그 이유는 자바 프로그램은 완전한 기계어가 아닌, 중간 단계의 **바이트 코드**이기 때문에 이것을 해석하고 실행할 수 있는 가상의 운영체제가 필요하다. 이것이 **자바 가상 기계(JVM: Java Virtual Machine)** 이다. JVM은 실 운영체제를 대신해서 자바 프로그램을 실행하는 가상의 운영체제 역활을 한다. 정리하면, JVM (Java Virtual Machine)은 **자바 바이트코드를 실행할 수 있는 있게 해주는 주체**이다.  

## 1-2 바이트코드란 무엇인가

### **바이너리 코드**

![1-1](https://user-images.githubusercontent.com/55661631/103167030-035c1900-486b-11eb-863f-e96ce42affcc.PNG)

* 바이너리 코드는 **컴퓨터가 이해할 수 있는 0과 1로 구성된 이진코드**를 의미한다.  
* C의 경우는, 우리가 알 수 있는 고급언어인 소스코드(```*.c```)가 컴파일되어 어셈블리어(```*.obj```)로 변환될 때 바이너리 파일로 변환된다. (0과 1) 어셈블리어(```*.obj```)는 컴퓨터가 이해할 수 있지만 완전한 기계어가 아니기 때문에 실행될 수는 없다. 변환된 어셈블리어(```*.obj```)는 링커에 의해 실행 가능한 실행파일(```*.exe```)로 변환될 때 여러 개의 코드와 데이터를 모아서 연결하여 메모리에서 실행 가능 한 파일로 만든다. 이러한 과정을 거쳐야 비로소 컴퓨터가 바로 실행 할 수 있는 기계어가 된다.

### **기계어**
* 기계어는 0과 1로 이루어진 바이너리 코드이다.
* **기계어가 이진코드로 이루어졌을 뿐이지 모든 이진코드가 기계어인 것은 아니다.**
* **기계어는 특정한 언어가 아니다.**
    - CPU 제조사마다 CPU를 만들때 사용할 수 있는 명령어를 공개하며, 이를 '기계어'라고 부를 뿐이다. 만약 CPU가 변경되면 기계어도 달라진다. 같은 동작을 하는 명령어이지만 0과 1을 인식하는 단위나 방법이 다를 수 있기 때문이다.

### **바이트코드**
* 자바 바이트 코드(Java bytecode)란 자바 가상 머신이 이해할 수 있는 언어로 변환된 자바 소스 코드를 의미한다.
* 자바 컴파일러에 의해 변환되는 코드의 명령어 크기가 1바이트라서 자바 바이트 코드라고 불리고 있다.
* 자바 바이트 코드의 확장자는 ```.class``` 이다.
* 자바 바이트 코드는 자바 가상 머신만 설치되어 있으면, 어떤 운영체제에서라도 실행될 수 있다.

## 1-3 JIT 컴파일러란 무엇이며 어떻게 동작하는지

### **전통적인 컴퓨터 프로그램 만드는 방법**
* 인터프리터 방식 - 실행 중 프로그래밍 언어를 읽어가면서 해당 기능에 대응하는 기계어 코드를 실행 (동적, **한줄 씩 번역하여 실행**)
* 컴파일 방식 - 실행하기 전에 프로그램 코드를 기계어로 번역하여 실행 (정적, **한번에 번역 후 실행**)

### **JIT(Just-In-Time)**
* **JIT 컴파일러는 인터프리터, 컴파일 방식을 혼합한 방식이다.**
* JIT 컴파일러의 동작방식
    - 바이트코드를 네이티브 코드로 컴파일해주는 역활
    - 인터프리터 효율을 높이기 위해, 인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러로 반복되는 코드를 모두 네이티브 코드로 바꿔둔다. 그 다음부터 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 사용한다.
* JIT 컴파일러의 장점
    - 기계어 변환(네이티브 코드로 바꾸는 작업)은 코드가 실행되는 과정에 실시간으로 일어나며(그래서 Just-In-Time이다), 전체 코드의 필요한 부분만 변환한다. 기계어로 변환된 코드는 캐시에 저장되기 때문에 재사용시 컴파일을 다시 할 필요가 없고 컴파일된 코드를 바로 사용한다.
    - 일반적인 인터프러터 언어에 비해 훨씬 좋은 성능을 낸다. 또한, 경우에 따라 정적 컴파일러 언어보다 좋은 성능을 내곤 하는데, 이는 실행 과정에 컴파일을 할 수 있기 때문이다.

## 1-4 JVM 구성요소

![1-2](https://user-images.githubusercontent.com/55661631/103167039-10790800-486b-11eb-9912-f4e076da30a1.PNG)  
출처 : https://medium.com/webeveloper/jvm-java-virtual-machine-architecture-94b914e93d86

### **클래스 로더** 
클래스 로더는 로딩, 링크, 초기화 순서로 진행됩니다. 클래스 로더라는 이름 그대로 클래스 파일을 적재(Runtime Data Area) 하는 역할을 한다. 즉, ```Event.java``` 자바 소스 파일을 컴파일 하면 바이트 코드(```.class 파일```)이 생성되며 이런 파일들을 모아, 클래스 로더가 메모리에 적재시킨다.
* 로딩 : 클래스를 읽어오는 과정
* 링크 : 레퍼런스를 연결하는 과정
* 초기화 : static 값들 초기화 및 변수에 할당

### **런타임 데이터 영역**
* 메서드 영역
    - 클래스 맴버 변수 이름, 데이터 타입, 리턴타입, 상수풀, static 변수 등이 저장된다.
    - 클래스 수준의 정보가 저장된다.
    - 여기에 저장된 정보들은 **공유**된다.
* 힙 영역
    - **new** 연산자로 생성된 객체와 배열이 저장된다.
    - Method 영역에 로드된 class만 생성 가능하며 GC가 참조되지 않은 메모리를 확인하고 제거하는 영역
* 스택 영역
    - 스레드마다 런타임 스택을 만들고, 그 안에 메서드 호출을 스택 프레임이라 부르는 블럭으로 쌓는다
    - 스레드 종료하면 런타임 스택도 사라진다. (main 스레드 포함 모든 스레드 종료시 프로세스 종료)
* PC(Program Counter)
    - 스레드마다 스레드 내 현재 실행하고 있는 부분의 포인터(주소)를 PC라 한다.
    - **프로세스내에서 스레드끼리의 컨텍스트 스위칭을 할 때 실행 주소를 저장하기 위해 사용된다.**
* 네이티브 메서드 스택
    - 자바 언어 이외의 언어로 작성된 코드를 저장하는 메모리 영역입니다. 주로 **native** 키워드가 붙은 애들이 저장된다.

### **실행 엔진**
* 인터프리터
* JIT 컴파일러
* GC(Garbage Collector)

## 1-5 JDK와 JRE의 차이

![1-3](https://user-images.githubusercontent.com/55661631/103167043-1bcc3380-486b-11eb-8d18-78c6fa2c68b5.PNG)

* JRE
    - 자바 애플리케이션을 실행할 수 있도록 구성된 배포판
    - JVM과 핵심 라이브러리 및 자바 런타임 환경에서 사용하는 프로퍼티 세팅이나 리소스 파일을 가지고 있다.
* JDK
    - JRE + 개발에 필요한 툴

## 1-6 컴파일하는 방법
```
$ javac sourcefile.java
```
* 소스파일(```*.java```)를 바이트코드(```*.class```)로 변환시킨다.
* 컴파일 시 ```javac.exe``` 를 사용한다.
 
## 1-7 실행하는 방법
```
$ java sourcefile
```
* ```javac.exe``` 를 사용하여 **바이트코드**로 컴파일 된 ```*.class```를 실행한다.

# 참고
* 이것이 자바다 - 신용권
* http://www.tcpschool.com/java/java_intro_programming
* https://medium.com/webeveloper/jvm-java-virtual-machine-architecture-94b914e93d86
